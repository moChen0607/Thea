<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Thea: RangeQueryStructure&lt; T &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Thea
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d8/d8a/namespaceThea.html">Thea</a></li><li class="navelem"><a class="el" href="../../d7/db8/namespaceThea_1_1Algorithms.html">Algorithms</a></li><li class="navelem"><a class="el" href="../../d6/df4/classThea_1_1Algorithms_1_1RangeQueryStructure.html">RangeQueryStructure</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d7/d6e/classThea_1_1Algorithms_1_1RangeQueryStructure-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RangeQueryStructure&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for a structure that supports range queries.  
 <a href="../../d6/df4/classThea_1_1Algorithms_1_1RangeQueryStructure.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d8/d1f/RangeQueryStructure_8hpp_source.html">RangeQueryStructure.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RangeQueryStructure&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d6/df4/classThea_1_1Algorithms_1_1RangeQueryStructure.png" usemap="#RangeQueryStructure_3C_20T_20_3E_map" alt=""/>
  <map id="RangeQueryStructure_3C_20T_20_3E_map" name="RangeQueryStructure&lt; T &gt;_map">
<area href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html" title="A kd-tree for a set of bounded objects in N-space. " alt="KDTreeN&lt; T, N, ScalarT, NodeAttributeT &gt;" shape="rect" coords="0,56,259,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad80159a5aed74b3117617a960bb9b874"><td class="memTemplParams" colspan="2">template&lt;typename IntersectionTesterT , typename RangeT , typename FunctorT &gt; </td></tr>
<tr class="memitem:ad80159a5aed74b3117617a960bb9b874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/df4/classThea_1_1Algorithms_1_1RangeQueryStructure.html#ad80159a5aed74b3117617a960bb9b874">processRangeUntil</a> (RangeT const &amp;range, FunctorT functor) const </td></tr>
<tr class="memdesc:ad80159a5aed74b3117617a960bb9b874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to all objects in a range, until the functor returns true.  <a href="#ad80159a5aed74b3117617a960bb9b874">More...</a><br /></td></tr>
<tr class="separator:ad80159a5aed74b3117617a960bb9b874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8717983c70e7973213935b68cca6552"><td class="memTemplParams" colspan="2">template&lt;typename IntersectionTesterT , typename RangeT , typename FunctorT &gt; </td></tr>
<tr class="memitem:ad8717983c70e7973213935b68cca6552"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/df4/classThea_1_1Algorithms_1_1RangeQueryStructure.html#ad8717983c70e7973213935b68cca6552">processRangeUntil</a> (RangeT const &amp;range, FunctorT functor)</td></tr>
<tr class="memdesc:ad8717983c70e7973213935b68cca6552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to all objects in a range, until the functor returns true.  <a href="#ad8717983c70e7973213935b68cca6552">More...</a><br /></td></tr>
<tr class="separator:ad8717983c70e7973213935b68cca6552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4a41300a564c8bb25c7d0f44e4a93b"><td class="memTemplParams" colspan="2">template&lt;typename IntersectionTesterT , typename RangeT &gt; </td></tr>
<tr class="memitem:adb4a41300a564c8bb25c7d0f44e4a93b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/df4/classThea_1_1Algorithms_1_1RangeQueryStructure.html#adb4a41300a564c8bb25c7d0f44e4a93b">rangeQuery</a> (RangeT const &amp;range, <a class="el" href="../../d8/d8a/namespaceThea.html#abb257f9b3a48e93d3c1c12d1b307d59f">Array</a>&lt; T &gt; &amp;result, bool discard_prior_results=true) const </td></tr>
<tr class="memdesc:adb4a41300a564c8bb25c7d0f44e4a93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all objects intersecting a range.  <a href="#adb4a41300a564c8bb25c7d0f44e4a93b">More...</a><br /></td></tr>
<tr class="separator:adb4a41300a564c8bb25c7d0f44e4a93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada82d381561e5c3c020ab34db3725fa5"><td class="memTemplParams" colspan="2">template&lt;typename IntersectionTesterT , typename RangeT &gt; </td></tr>
<tr class="memitem:ada82d381561e5c3c020ab34db3725fa5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/df4/classThea_1_1Algorithms_1_1RangeQueryStructure.html#ada82d381561e5c3c020ab34db3725fa5">rangeQueryIndices</a> (RangeT const &amp;range, <a class="el" href="../../d8/d8a/namespaceThea.html#abb257f9b3a48e93d3c1c12d1b307d59f">Array</a>&lt; <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> &gt; &amp;result, bool discard_prior_results=true) const </td></tr>
<tr class="memdesc:ada82d381561e5c3c020ab34db3725fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indices of all objects intersecting a range.  <a href="#ada82d381561e5c3c020ab34db3725fa5">More...</a><br /></td></tr>
<tr class="separator:ada82d381561e5c3c020ab34db3725fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class Thea::Algorithms::RangeQueryStructure&lt; T &gt;</h3>

<p>Interface for a structure that supports range queries. </p>
<p>None of the functions are virtual, this just defines a concept subclasses must implement. </p>

<p>Definition at line <a class="el" href="../../d8/d1f/RangeQueryStructure_8hpp_source.html#l00029">29</a> of file <a class="el" href="../../d8/d1f/RangeQueryStructure_8hpp_source.html">RangeQueryStructure.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad80159a5aed74b3117617a960bb9b874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> processRangeUntil </td>
          <td>(</td>
          <td class="paramtype">RangeT const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctorT&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a functor to all objects in a range, until the functor returns true. </p>
<p>The functor should provide the member function (or be a function pointer with the equivalent signature) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator()(<a class="code" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> index, T <span class="keyword">const</span> &amp; t)</div></div><!-- fragment --><p> and will be passed the index of each object contained in the range as well as a handle to the object itself. If the functor returns true on any object, the search will terminate immediately (this is useful for searching for a particular object). To pass a functor by reference, wrap it in <code>std::ref</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first object in the range for which the functor evaluated to true (the search stopped immediately after processing this object), else a negative value. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8717983c70e7973213935b68cca6552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> processRangeUntil </td>
          <td>(</td>
          <td class="paramtype">RangeT const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctorT&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a functor to all objects in a range, until the functor returns true. </p>
<p>The functor should provide the member function (or be a function pointer with the equivalent signature) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator()(<a class="code" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> index, T [<span class="keyword">const</span>] &amp; t)</div></div><!-- fragment --><p> and will be passed the index of each object contained in the range as well as a handle to the object itself. If the functor returns true on any object, the search will terminate immediately (this is useful for searching for a particular object). To pass a functor by reference, wrap it in <code>std::ref</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first object in the range for which the functor evaluated to true (the search stopped immediately after processing this object), else a negative value. </dd></dl>

</div>
</div>
<a class="anchor" id="adb4a41300a564c8bb25c7d0f44e4a93b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rangeQuery </td>
          <td>(</td>
          <td class="paramtype">RangeT const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#abb257f9b3a48e93d3c1c12d1b307d59f">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discard_prior_results</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all objects intersecting a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to search in. </td></tr>
    <tr><td class="paramname">result</td><td>The objects intersecting the range are stored here. </td></tr>
    <tr><td class="paramname">discard_prior_results</td><td>If true, the contents of <em>results</em> are cleared before the range query proceeds. If false, the previous results are retained and new objects are appended to the array (this is useful for range queries over a union of simpler ranges). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada82d381561e5c3c020ab34db3725fa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rangeQueryIndices </td>
          <td>(</td>
          <td class="paramtype">RangeT const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#abb257f9b3a48e93d3c1c12d1b307d59f">Array</a>&lt; <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discard_prior_results</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the indices of all objects intersecting a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to search in. </td></tr>
    <tr><td class="paramname">result</td><td>The indices of objects intersecting the range are stored here. </td></tr>
    <tr><td class="paramname">discard_prior_results</td><td>If true, the contents of <em>results</em> are cleared before the range query proceeds. If false, the previous results are retained and indices of new objects are appended to the array (this is useful for range queries over a union of simpler ranges). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="../../d8/d1f/RangeQueryStructure_8hpp_source.html">RangeQueryStructure.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
