<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Thea: KDTreeN&lt; T, N, ScalarT, NodeAttributeT &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Thea
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d8/d8a/namespaceThea.html">Thea</a></li><li class="navelem"><a class="el" href="../../d7/db8/namespaceThea_1_1Algorithms.html">Algorithms</a></li><li class="navelem"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html">KDTreeN</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="../../d5/d80/classThea_1_1Algorithms_1_1KDTreeN-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">KDTreeN&lt; T, N, ScalarT, NodeAttributeT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A kd-tree for a set of bounded objects in N-space.  
 <a href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for KDTreeN&lt; T, N, ScalarT, NodeAttributeT &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.png" usemap="#KDTreeN_3C_20T_2C_20N_2C_20ScalarT_2C_20NodeAttributeT_20_3E_map" alt=""/>
  <map id="KDTreeN_3C_20T_2C_20N_2C_20ScalarT_2C_20NodeAttributeT_20_3E_map" name="KDTreeN&lt; T, N, ScalarT, NodeAttributeT &gt;_map">
<area href="../../d6/df4/classThea_1_1Algorithms_1_1RangeQueryStructure.html" title="Interface for a structure that supports range queries. " alt="RangeQueryStructure&lt; T &gt;" shape="rect" coords="0,0,303,24"/>
<area href="../../d3/d59/classThea_1_1Algorithms_1_1ProximityQueryStructureN.html" alt="ProximityQueryStructureN&lt; N, ScalarT &gt;" shape="rect" coords="313,0,616,24"/>
<area href="../../d2/d79/classThea_1_1Algorithms_1_1RayQueryStructureN.html" alt="RayQueryStructureN&lt; N, ScalarT &gt;" shape="rect" coords="626,0,929,24"/>
<area href="../../d2/dac/classThea_1_1Transformable.html" alt="Transformable&lt; AffineTransformN&lt; N, ScalarT &gt; &gt;" shape="rect" coords="939,0,1242,24"/>
<area href="../../d4/d99/classThea_1_1Noncopyable.html" title="A base class for objects that should never be copied. " alt="Noncopyable" shape="rect" coords="1252,0,1555,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node of the kd-tree.  <a href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a875381ebdccdea47b5186d6ddafc7ad2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d8/d00/classThea_1_1AxisAlignedBoxN.html">AxisAlignedBoxN</a>&lt; N, ScalarT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a></td></tr>
<tr class="memdesc:a875381ebdccdea47b5186d6ddafc7ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis-aligned box in N-space.  <a href="#a875381ebdccdea47b5186d6ddafc7ad2">More...</a><br /></td></tr>
<tr class="separator:a875381ebdccdea47b5186d6ddafc7ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4934da7318f3e9fc85ec5874c3be647f"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a4934da7318f3e9fc85ec5874c3be647f">Element</a></td></tr>
<tr class="memdesc:a4934da7318f3e9fc85ec5874c3be647f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of elements in the kd-tree.  <a href="#a4934da7318f3e9fc85ec5874c3be647f">More...</a><br /></td></tr>
<tr class="separator:a4934da7318f3e9fc85ec5874c3be647f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87fbc68d23e29dcbe2614788d0deb45"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab87fbc68d23e29dcbe2614788d0deb45">ElementIndex</a></td></tr>
<tr class="memdesc:ab87fbc68d23e29dcbe2614788d0deb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of an element in the kd-tree.  <a href="#ab87fbc68d23e29dcbe2614788d0deb45">More...</a><br /></td></tr>
<tr class="separator:ab87fbc68d23e29dcbe2614788d0deb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4a6000e6b127e0b2dd46c9e0bc4052"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../de/df7/structThea_1_1Algorithms_1_1KDTreeNInternal_1_1ElementSample.html">KDTreeNInternal::ElementSample</a>&lt; N, ScalarT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a1c4a6000e6b127e0b2dd46c9e0bc4052">ElementSample</a></td></tr>
<tr class="memdesc:a1c4a6000e6b127e0b2dd46c9e0bc4052"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point sample drawn from a kd-tree element, used for accelerating nearest neighbor queries.  <a href="#a1c4a6000e6b127e0b2dd46c9e0bc4052">More...</a><br /></td></tr>
<tr class="separator:a1c4a6000e6b127e0b2dd46c9e0bc4052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524288d0b46887110d7dceb459043cbb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html">KDTreeN</a>&lt; <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a1c4a6000e6b127e0b2dd46c9e0bc4052">ElementSample</a>, N, ScalarT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a524288d0b46887110d7dceb459043cbb">NearestNeighborAccelerationStructure</a></td></tr>
<tr class="memdesc:a524288d0b46887110d7dceb459043cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to speed up nearest neighbor queries.  <a href="#a524288d0b46887110d7dceb459043cbb">More...</a><br /></td></tr>
<tr class="separator:a524288d0b46887110d7dceb459043cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54855b23107c5c176f3c16cf73995b5"><td class="memItemLeft" align="right" valign="top">typedef ProximityQueryBaseT::NeighborPair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac54855b23107c5c176f3c16cf73995b5">NeighborPair</a></td></tr>
<tr class="memdesc:ac54855b23107c5c176f3c16cf73995b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of neighboring elements.  <a href="#ac54855b23107c5c176f3c16cf73995b5">More...</a><br /></td></tr>
<tr class="separator:ac54855b23107c5c176f3c16cf73995b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242d1fc2443d7f425fcf0ea558d5b679"><td class="memItemLeft" align="right" valign="top">typedef NodeAttributeT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a242d1fc2443d7f425fcf0ea558d5b679">NodeAttribute</a></td></tr>
<tr class="memdesc:a242d1fc2443d7f425fcf0ea558d5b679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes attached to nodes.  <a href="#a242d1fc2443d7f425fcf0ea558d5b679">More...</a><br /></td></tr>
<tr class="separator:a242d1fc2443d7f425fcf0ea558d5b679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab170f96ea50d059e02bb13d8ab8f5413"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../dd/d79/classThea_1_1Algorithms_1_1RayStructureIntersectionN.html">RayQueryBaseT::RayStructureIntersectionT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab170f96ea50d059e02bb13d8ab8f5413">RayStructureIntersectionT</a></td></tr>
<tr class="memdesc:ab170f96ea50d059e02bb13d8ab8f5413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray intersection structure in N-space.  <a href="#ab170f96ea50d059e02bb13d8ab8f5413">More...</a><br /></td></tr>
<tr class="separator:ab170f96ea50d059e02bb13d8ab8f5413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371f4385228bd62d1d868083b584ee2f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d5/d24/classThea_1_1RayN.html">RayQueryBaseT::RayT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a371f4385228bd62d1d868083b584ee2f">RayT</a></td></tr>
<tr class="memdesc:a371f4385228bd62d1d868083b584ee2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray in N-space.  <a href="#a371f4385228bd62d1d868083b584ee2f">More...</a><br /></td></tr>
<tr class="separator:a371f4385228bd62d1d868083b584ee2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0363e81fbb0d24325465c7c90febb959"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d2/dac/classThea_1_1Transformable.html#a85809ea08c1d3b453930f67c419dd7e0">TransformableBaseT::Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0363e81fbb0d24325465c7c90febb959">Transform</a></td></tr>
<tr class="memdesc:a0363e81fbb0d24325465c7c90febb959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform applied to the kd-tree.  <a href="#a0363e81fbb0d24325465c7c90febb959">More...</a><br /></td></tr>
<tr class="separator:a0363e81fbb0d24325465c7c90febb959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265a253612b46abed17c61b0a5e5ce30"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a265a253612b46abed17c61b0a5e5ce30">value_type</a></td></tr>
<tr class="memdesc:a265a253612b46abed17c61b0a5e5ce30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of elements in the kd-tree (STL convention).  <a href="#a265a253612b46abed17c61b0a5e5ce30">More...</a><br /></td></tr>
<tr class="separator:a265a253612b46abed17c61b0a5e5ce30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91769fe82094870fe51f1f13782e6a6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d3/d59/classThea_1_1Algorithms_1_1ProximityQueryStructureN.html#a890d691eac7daa6c17cab30cb66c363c">ProximityQueryBaseT::VectorT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac91769fe82094870fe51f1f13782e6a6">VectorT</a></td></tr>
<tr class="memdesc:ac91769fe82094870fe51f1f13782e6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector in N-space.  <a href="#ac91769fe82094870fe51f1f13782e6a6">More...</a><br /></td></tr>
<tr class="separator:ac91769fe82094870fe51f1f13782e6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a04b62feda5e8171278c168560ab973b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a04b62feda5e8171278c168560ab973b3">clear</a> (bool deallocate_all_memory=true)</td></tr>
<tr class="memdesc:a04b62feda5e8171278c168560ab973b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the tree.  <a href="#a04b62feda5e8171278c168560ab973b3">More...</a><br /></td></tr>
<tr class="separator:a04b62feda5e8171278c168560ab973b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5194d53d0d61f07f51f0a8164664ff8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a5194d53d0d61f07f51f0a8164664ff8a">clearTransform</a> ()</td></tr>
<tr class="memdesc:a5194d53d0d61f07f51f0a8164664ff8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear any existing transform.  <a href="#a5194d53d0d61f07f51f0a8164664ff8a">More...</a><br /></td></tr>
<tr class="separator:a5194d53d0d61f07f51f0a8164664ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf443292546df41e4b298acb76e7e98"><td class="memTemplParams" colspan="2">template&lt;typename MetricT , typename QueryT &gt; </td></tr>
<tr class="memitem:addf443292546df41e4b298acb76e7e98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#addf443292546df41e4b298acb76e7e98">closestElement</a> (QueryT const &amp;query, double dist_bound=-1, double *dist=nullptr, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac91769fe82094870fe51f1f13782e6a6">VectorT</a> *closest_point=nullptr) const </td></tr>
<tr class="memdesc:addf443292546df41e4b298acb76e7e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the closest element in this structure to a query object, within a specified distance bound.  <a href="#addf443292546df41e4b298acb76e7e98">More...</a><br /></td></tr>
<tr class="separator:addf443292546df41e4b298acb76e7e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41057802be63897099f3db13f1decf5f"><td class="memTemplParams" colspan="2">template&lt;typename MetricT , typename QueryT &gt; </td></tr>
<tr class="memitem:a41057802be63897099f3db13f1decf5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac54855b23107c5c176f3c16cf73995b5">NeighborPair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a41057802be63897099f3db13f1decf5f">closestPair</a> (QueryT const &amp;query, double dist_bound=-1, bool get_closest_points=false) const </td></tr>
<tr class="memdesc:a41057802be63897099f3db13f1decf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the closest pair of elements between this structure and another structure, whose separation is less than a specified upper bound.  <a href="#a41057802be63897099f3db13f1decf5f">More...</a><br /></td></tr>
<tr class="separator:a41057802be63897099f3db13f1decf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a96d2213825c6bf28342773ac425238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a4a96d2213825c6bf28342773ac425238">disableNearestNeighborAcceleration</a> (bool deallocate_memory=true)</td></tr>
<tr class="memdesc:a4a96d2213825c6bf28342773ac425238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable acceleration of nearest neighbor queries with an auxiliary structure on a sparse set of points.  <a href="#a4a96d2213825c6bf28342773ac425238">More...</a><br /></td></tr>
<tr class="separator:a4a96d2213825c6bf28342773ac425238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ac8a2ac42b7f67a21f5bb6319d3dc6"><td class="memTemplParams" colspan="2">template&lt;typename MetricT , typename QueryT &gt; </td></tr>
<tr class="memitem:aa9ac8a2ac42b7f67a21f5bb6319d3dc6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#aa9ac8a2ac42b7f67a21f5bb6319d3dc6">distance</a> (QueryT const &amp;query, double dist_bound=-1) const </td></tr>
<tr class="memdesc:aa9ac8a2ac42b7f67a21f5bb6319d3dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum distance between this structure and a query object.  <a href="#aa9ac8a2ac42b7f67a21f5bb6319d3dc6">More...</a><br /></td></tr>
<tr class="separator:aa9ac8a2ac42b7f67a21f5bb6319d3dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80efb6a0fb227ff77596fac6e21eea21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a80efb6a0fb227ff77596fac6e21eea21">enableNearestNeighborAcceleration</a> (<a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> num_acceleration_samples_=-1)</td></tr>
<tr class="memdesc:a80efb6a0fb227ff77596fac6e21eea21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable acceleration of nearest neighbor queries with an auxiliary structure on a sparse set of points.  <a href="#a80efb6a0fb227ff77596fac6e21eea21">More...</a><br /></td></tr>
<tr class="separator:a80efb6a0fb227ff77596fac6e21eea21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaccc93fb5e4c3614a4f9bf154235093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#acaccc93fb5e4c3614a4f9bf154235093">getBounds</a> () const </td></tr>
<tr class="memdesc:acaccc93fb5e4c3614a4f9bf154235093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a bounding box for all the objects in the tree.  <a href="#acaccc93fb5e4c3614a4f9bf154235093">More...</a><br /></td></tr>
<tr class="separator:acaccc93fb5e4c3614a4f9bf154235093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99adbb805fa0ec695da093ee855a02b"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab99adbb805fa0ec695da093ee855a02b">getElements</a> () const </td></tr>
<tr class="memdesc:ab99adbb805fa0ec695da093ee855a02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an array of the elements in the tree.  <a href="#ab99adbb805fa0ec695da093ee855a02b">More...</a><br /></td></tr>
<tr class="separator:ab99adbb805fa0ec695da093ee855a02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe7e195b96ae7b031adbf04e6f20278"><td class="memTemplParams" colspan="2">template&lt;typename MetricT &gt; </td></tr>
<tr class="memitem:a1fe7e195b96ae7b031adbf04e6f20278"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a524288d0b46887110d7dceb459043cbb">NearestNeighborAccelerationStructure</a> const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a1fe7e195b96ae7b031adbf04e6f20278">getNearestNeighborAccelerationStructure</a> () const </td></tr>
<tr class="memdesc:a1fe7e195b96ae7b031adbf04e6f20278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the auxiliary structure to accelerate nearest neighbor queries, if available.  <a href="#a1fe7e195b96ae7b031adbf04e6f20278">More...</a><br /></td></tr>
<tr class="separator:a1fe7e195b96ae7b031adbf04e6f20278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e6b100197f0fa9d27784a7a6293aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a96e6b100197f0fa9d27784a7a6293aab">getRoot</a> () const </td></tr>
<tr class="memdesc:a96e6b100197f0fa9d27784a7a6293aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node corresponding to the root of the kd-tree.  <a href="#a96e6b100197f0fa9d27784a7a6293aab">More...</a><br /></td></tr>
<tr class="separator:a96e6b100197f0fa9d27784a7a6293aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fae8384e3a66bcdd66f486c3aea194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0363e81fbb0d24325465c7c90febb959">Transform</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dac/classThea_1_1Transformable.html#ad2fae8384e3a66bcdd66f486c3aea194">getTransform</a> () const</td></tr>
<tr class="memdesc:ad2fae8384e3a66bcdd66f486c3aea194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation, if one has been set.  <a href="#ad2fae8384e3a66bcdd66f486c3aea194">More...</a><br /></td></tr>
<tr class="separator:ad2fae8384e3a66bcdd66f486c3aea194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8032ce8490b139f6491c1fe23f4fa85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0363e81fbb0d24325465c7c90febb959">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dac/classThea_1_1Transformable.html#af8032ce8490b139f6491c1fe23f4fa85">getTransform</a> ()</td></tr>
<tr class="memdesc:af8032ce8490b139f6491c1fe23f4fa85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation, if one has been set.  <a href="#af8032ce8490b139f6491c1fe23f4fa85">More...</a><br /></td></tr>
<tr class="separator:af8032ce8490b139f6491c1fe23f4fa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef15c549121a48e056a39a4170f943ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#aef15c549121a48e056a39a4170f943ac">hasNearestNeighborAcceleration</a> () const </td></tr>
<tr class="memdesc:aef15c549121a48e056a39a4170f943ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if nearest neighbor queries are accelerated by an auxiliary structure.  <a href="#aef15c549121a48e056a39a4170f943ac">More...</a><br /></td></tr>
<tr class="separator:aef15c549121a48e056a39a4170f943ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9cd00d6d0ca5c0515f3f7596640b28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dac/classThea_1_1Transformable.html#ade9cd00d6d0ca5c0515f3f7596640b28">hasTransform</a> () const</td></tr>
<tr class="memdesc:ade9cd00d6d0ca5c0515f3f7596640b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transform has been set.  <a href="#ade9cd00d6d0ca5c0515f3f7596640b28">More...</a><br /></td></tr>
<tr class="separator:ade9cd00d6d0ca5c0515f3f7596640b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bf07e86660e315c666e3dd91872f71"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a82bf07e86660e315c666e3dd91872f71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a82bf07e86660e315c666e3dd91872f71">init</a> (InputIterator begin, InputIterator end, <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> max_depth_=-1, <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> max_elems_per_leaf_=-1, bool save_memory=false, bool deallocate_previous_memory=true)</td></tr>
<tr class="memdesc:a82bf07e86660e315c666e3dd91872f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a list of elements.  <a href="#a82bf07e86660e315c666e3dd91872f71">More...</a><br /></td></tr>
<tr class="separator:a82bf07e86660e315c666e3dd91872f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479432127ee77145cc19d6a2d1590821"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a479432127ee77145cc19d6a2d1590821">isEmpty</a> () const </td></tr>
<tr class="memdesc:a479432127ee77145cc19d6a2d1590821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the tree is empty.  <a href="#a479432127ee77145cc19d6a2d1590821">More...</a><br /></td></tr>
<tr class="separator:a479432127ee77145cc19d6a2d1590821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ff95c512dee13ebb81b32bf810ecc9"><td class="memTemplParams" colspan="2">template&lt;typename MetricT , typename QueryT , typename BoundedNeighborPairSetT &gt; </td></tr>
<tr class="memitem:a89ff95c512dee13ebb81b32bf810ecc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a89ff95c512dee13ebb81b32bf810ecc9">kClosestPairs</a> (QueryT const &amp;query, BoundedNeighborPairSetT &amp;k_closest_pairs, double dist_bound=-1, bool get_closest_points=false, bool clear_set=true, <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> use_as_query_index_and_swap=-1) const </td></tr>
<tr class="memdesc:a89ff95c512dee13ebb81b32bf810ecc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the k elements closest to a query object.  <a href="#a89ff95c512dee13ebb81b32bf810ecc9">More...</a><br /></td></tr>
<tr class="separator:a89ff95c512dee13ebb81b32bf810ecc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c04ec42e6cacebf66a3bb44ffa30764"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0c04ec42e6cacebf66a3bb44ffa30764">KDTreeN</a> ()</td></tr>
<tr class="memdesc:a0c04ec42e6cacebf66a3bb44ffa30764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a0c04ec42e6cacebf66a3bb44ffa30764">More...</a><br /></td></tr>
<tr class="separator:a0c04ec42e6cacebf66a3bb44ffa30764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01a1a837c09a1131d545a130246ed63"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:af01a1a837c09a1131d545a130246ed63"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#af01a1a837c09a1131d545a130246ed63">KDTreeN</a> (InputIterator begin, InputIterator end, <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> max_depth_=-1, <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> max_elems_per_leaf_=-1, bool save_memory=false)</td></tr>
<tr class="memdesc:af01a1a837c09a1131d545a130246ed63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a list of elements.  <a href="#af01a1a837c09a1131d545a130246ed63">More...</a><br /></td></tr>
<tr class="separator:af01a1a837c09a1131d545a130246ed63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8236ea4ff413ae88c2eb98ec0e32af7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a8236ea4ff413ae88c2eb98ec0e32af7b">maxDepth</a> () const </td></tr>
<tr class="memdesc:a8236ea4ff413ae88c2eb98ec0e32af7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum subdivision depth (number of levels not counting the root) of the kd-tree.  <a href="#a8236ea4ff413ae88c2eb98ec0e32af7b">More...</a><br /></td></tr>
<tr class="separator:a8236ea4ff413ae88c2eb98ec0e32af7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28b0f742ad94b0e5b582e4b618509a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab28b0f742ad94b0e5b582e4b618509a1">maxElementsPerLeaf</a> () const </td></tr>
<tr class="memdesc:ab28b0f742ad94b0e5b582e4b618509a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of elements in each leaf of the kd-tree.  <a href="#ab28b0f742ad94b0e5b582e4b618509a1">More...</a><br /></td></tr>
<tr class="separator:ab28b0f742ad94b0e5b582e4b618509a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933c5a6612b1378198c92b1a51ccd808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a933c5a6612b1378198c92b1a51ccd808">numElements</a> () const </td></tr>
<tr class="memdesc:a933c5a6612b1378198c92b1a51ccd808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements in the tree.  <a href="#a933c5a6612b1378198c92b1a51ccd808">More...</a><br /></td></tr>
<tr class="separator:a933c5a6612b1378198c92b1a51ccd808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae54574dd3a837be054a38deb73fe0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#aeae54574dd3a837be054a38deb73fe0c">numNodes</a> () const </td></tr>
<tr class="memdesc:aeae54574dd3a837be054a38deb73fe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nodes in the tree.  <a href="#aeae54574dd3a837be054a38deb73fe0c">More...</a><br /></td></tr>
<tr class="separator:aeae54574dd3a837be054a38deb73fe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f66d5fae81b5d5e30d823c2e133b826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a7f66d5fae81b5d5e30d823c2e133b826">popFilter</a> ()</td></tr>
<tr class="memdesc:a7f66d5fae81b5d5e30d823c2e133b826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the last pushed element filter off the filter stack.  <a href="#a7f66d5fae81b5d5e30d823c2e133b826">More...</a><br /></td></tr>
<tr class="separator:a7f66d5fae81b5d5e30d823c2e133b826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80159a5aed74b3117617a960bb9b874"><td class="memTemplParams" colspan="2">template&lt;typename IntersectionTesterT , typename RangeT , typename FunctorT &gt; </td></tr>
<tr class="memitem:ad80159a5aed74b3117617a960bb9b874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ad80159a5aed74b3117617a960bb9b874">processRangeUntil</a> (RangeT const &amp;range, FunctorT functor) const </td></tr>
<tr class="memdesc:ad80159a5aed74b3117617a960bb9b874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to all objects in a range, until the functor returns true.  <a href="#ad80159a5aed74b3117617a960bb9b874">More...</a><br /></td></tr>
<tr class="separator:ad80159a5aed74b3117617a960bb9b874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8717983c70e7973213935b68cca6552"><td class="memTemplParams" colspan="2">template&lt;typename IntersectionTesterT , typename RangeT , typename FunctorT &gt; </td></tr>
<tr class="memitem:ad8717983c70e7973213935b68cca6552"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ad8717983c70e7973213935b68cca6552">processRangeUntil</a> (RangeT const &amp;range, FunctorT functor)</td></tr>
<tr class="memdesc:ad8717983c70e7973213935b68cca6552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to all objects in a range, until the functor returns true.  <a href="#ad8717983c70e7973213935b68cca6552">More...</a><br /></td></tr>
<tr class="separator:ad8717983c70e7973213935b68cca6552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b54e2357eee85dffac2ede1da3fee3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a7b54e2357eee85dffac2ede1da3fee3c">pushFilter</a> (<a class="el" href="../../d4/df0/classThea_1_1Algorithms_1_1Filter.html">Filter</a>&lt; T &gt; *filter)</td></tr>
<tr class="memdesc:a7b54e2357eee85dffac2ede1da3fee3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element filter onto the filter stack.  <a href="#a7b54e2357eee85dffac2ede1da3fee3c">More...</a><br /></td></tr>
<tr class="separator:a7b54e2357eee85dffac2ede1da3fee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4a41300a564c8bb25c7d0f44e4a93b"><td class="memTemplParams" colspan="2">template&lt;typename IntersectionTesterT , typename RangeT &gt; </td></tr>
<tr class="memitem:adb4a41300a564c8bb25c7d0f44e4a93b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#adb4a41300a564c8bb25c7d0f44e4a93b">rangeQuery</a> (RangeT const &amp;range, <a class="el" href="../../d8/d8a/namespaceThea.html#abb257f9b3a48e93d3c1c12d1b307d59f">Array</a>&lt; T &gt; &amp;result, bool discard_prior_results=true) const </td></tr>
<tr class="memdesc:adb4a41300a564c8bb25c7d0f44e4a93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all objects intersecting a range.  <a href="#adb4a41300a564c8bb25c7d0f44e4a93b">More...</a><br /></td></tr>
<tr class="separator:adb4a41300a564c8bb25c7d0f44e4a93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada82d381561e5c3c020ab34db3725fa5"><td class="memTemplParams" colspan="2">template&lt;typename IntersectionTesterT , typename RangeT &gt; </td></tr>
<tr class="memitem:ada82d381561e5c3c020ab34db3725fa5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ada82d381561e5c3c020ab34db3725fa5">rangeQueryIndices</a> (RangeT const &amp;range, <a class="el" href="../../d8/d8a/namespaceThea.html#abb257f9b3a48e93d3c1c12d1b307d59f">Array</a>&lt; <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> &gt; &amp;result, bool discard_prior_results=true) const </td></tr>
<tr class="memdesc:ada82d381561e5c3c020ab34db3725fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indices of all objects intersecting a range.  <a href="#ada82d381561e5c3c020ab34db3725fa5">More...</a><br /></td></tr>
<tr class="separator:ada82d381561e5c3c020ab34db3725fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319f007dd993d2c8f8e64c676ae0ac13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a319f007dd993d2c8f8e64c676ae0ac13">setTransform</a> (<a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0363e81fbb0d24325465c7c90febb959">Transform</a> const &amp;trans_)</td></tr>
<tr class="memdesc:a319f007dd993d2c8f8e64c676ae0ac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transformation.  <a href="#a319f007dd993d2c8f8e64c676ae0ac13">More...</a><br /></td></tr>
<tr class="separator:a319f007dd993d2c8f8e64c676ae0ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1b42712678c02bca7e4be6c2c06bf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a5d1b42712678c02bca7e4be6c2c06bf3">~KDTreeN</a> ()</td></tr>
<tr class="memdesc:a5d1b42712678c02bca7e4be6c2c06bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5d1b42712678c02bca7e4be6c2c06bf3">More...</a><br /></td></tr>
<tr class="separator:a5d1b42712678c02bca7e4be6c2c06bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a0c5180f373c10a232b47b1921aae5176"><td class="memItemLeft" align="right" valign="top">typedef MemoryPool&lt; <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab87fbc68d23e29dcbe2614788d0deb45">ElementIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0c5180f373c10a232b47b1921aae5176">IndexPool</a></td></tr>
<tr class="memdesc:a0c5180f373c10a232b47b1921aae5176"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool for quickly allocating element indices.  <a href="#a0c5180f373c10a232b47b1921aae5176">More...</a><br /></td></tr>
<tr class="separator:a0c5180f373c10a232b47b1921aae5176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585b9362aef8ebf372222a703484cff1"><td class="memItemLeft" align="right" valign="top">typedef MemoryPool&lt; <a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a585b9362aef8ebf372222a703484cff1">NodePool</a></td></tr>
<tr class="memdesc:a585b9362aef8ebf372222a703484cff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool for quickly allocating kd-tree nodes.  <a href="#a585b9362aef8ebf372222a703484cff1">More...</a><br /></td></tr>
<tr class="separator:a585b9362aef8ebf372222a703484cff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2bdb8d39ec0eaba54740f01767927643"><td class="memTemplParams" colspan="2">template&lt;typename MetricT , typename QueryT &gt; </td></tr>
<tr class="memitem:a2bdb8d39ec0eaba54740f01767927643"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a2bdb8d39ec0eaba54740f01767927643">closestPair</a> (<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *start, QueryT const &amp;query, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> const &amp;query_bounds, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac54855b23107c5c176f3c16cf73995b5">NeighborPair</a> &amp;pair, bool get_closest_points) const </td></tr>
<tr class="memdesc:a2bdb8d39ec0eaba54740f01767927643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively look for the closest pair of points between two elements.  <a href="#a2bdb8d39ec0eaba54740f01767927643">More...</a><br /></td></tr>
<tr class="separator:a2bdb8d39ec0eaba54740f01767927643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5315740fc19e420f9afe90261bb84c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#af5315740fc19e420f9afe90261bb84c0">createTree</a> (<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> *start, bool save_memory, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0c5180f373c10a232b47b1921aae5176">IndexPool</a> *main_index_pool, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0c5180f373c10a232b47b1921aae5176">IndexPool</a> *leaf_index_pool)</td></tr>
<tr class="memdesc:af5315740fc19e420f9afe90261bb84c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively construct a (sub-)tree.  <a href="#af5315740fc19e420f9afe90261bb84c0">More...</a><br /></td></tr>
<tr class="separator:af5315740fc19e420f9afe90261bb84c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b6d512e48ed4caf085ac34177b7051"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a76b6d512e48ed4caf085ac34177b7051">elementPassesFilters</a> (T const &amp;elem) const </td></tr>
<tr class="memdesc:a76b6d512e48ed4caf085ac34177b7051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an element passes all filters currently on the stack.  <a href="#a76b6d512e48ed4caf085ac34177b7051">More...</a><br /></td></tr>
<tr class="separator:a76b6d512e48ed4caf085ac34177b7051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ec6c2c2283541f93db84116a1315a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac2ec6c2c2283541f93db84116a1315a0">getBoundsWorldSpace</a> (<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const &amp;node) const </td></tr>
<tr class="memdesc:ac2ec6c2c2283541f93db84116a1315a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a bounding box for a node, in world space.  <a href="#ac2ec6c2c2283541f93db84116a1315a0">More...</a><br /></td></tr>
<tr class="separator:ac2ec6c2c2283541f93db84116a1315a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75ab2a335cc16872c6e14fc15949b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0c5180f373c10a232b47b1921aae5176">IndexPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ae75ab2a335cc16872c6e14fc15949b56">getIndexPool</a> ()</td></tr>
<tr class="memdesc:ae75ab2a335cc16872c6e14fc15949b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the main memory pool for indices.  <a href="#ae75ab2a335cc16872c6e14fc15949b56">More...</a><br /></td></tr>
<tr class="separator:ae75ab2a335cc16872c6e14fc15949b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b658e35cf4636403c454775705287d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a585b9362aef8ebf372222a703484cff1">NodePool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ad5b658e35cf4636403c454775705287d">getNodePool</a> ()</td></tr>
<tr class="memdesc:ad5b658e35cf4636403c454775705287d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the main memory pool for nodes.  <a href="#ad5b658e35cf4636403c454775705287d">More...</a><br /></td></tr>
<tr class="separator:ad5b658e35cf4636403c454775705287d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5776e04011ede490c95efe6af77613a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d17/classThea_1_1AffineTransformN.html">AffineTransformN</a>&lt; N, ScalarT &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a5776e04011ede490c95efe6af77613a9">getTransformInverse</a> () const </td></tr>
<tr class="memdesc:a5776e04011ede490c95efe6af77613a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inverse of the transform applied to the kd-tree.  <a href="#a5776e04011ede490c95efe6af77613a9">More...</a><br /></td></tr>
<tr class="separator:a5776e04011ede490c95efe6af77613a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab03d54a8bbcb4ad933573d1cfbab11d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a97ebcfaed8995f9f4231bb51135c6a21">Matrix</a>&lt; N, N, ScalarT &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#aab03d54a8bbcb4ad933573d1cfbab11d">getTransformInverseTranspose</a> () const </td></tr>
<tr class="memdesc:aab03d54a8bbcb4ad933573d1cfbab11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transpose of the inverse of the linear part of the transform applied to the kd-tree.  <a href="#aab03d54a8bbcb4ad933573d1cfbab11d">More...</a><br /></td></tr>
<tr class="separator:aab03d54a8bbcb4ad933573d1cfbab11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074e3a8329c1d56076c6a097d1e595f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a074e3a8329c1d56076c6a097d1e595f5">invalidateBounds</a> ()</td></tr>
<tr class="memdesc:a074e3a8329c1d56076c6a097d1e595f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the bounding box requires an update.  <a href="#a074e3a8329c1d56076c6a097d1e595f5">More...</a><br /></td></tr>
<tr class="separator:a074e3a8329c1d56076c6a097d1e595f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86feb2e29ff315e058816723f0edaf05"><td class="memTemplParams" colspan="2">template&lt;typename MetricT , typename QueryT , typename BoundedNeighborPairSet &gt; </td></tr>
<tr class="memitem:a86feb2e29ff315e058816723f0edaf05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a86feb2e29ff315e058816723f0edaf05">kClosestPairs</a> (<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *start, QueryT const &amp;query, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> const &amp;query_bounds, BoundedNeighborPairSet &amp;k_closest_pairs, double dist_bound, bool get_closest_points, <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> use_as_query_index_and_swap) const </td></tr>
<tr class="memdesc:a86feb2e29ff315e058816723f0edaf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively look for the k closest elements to a query object.  <a href="#a86feb2e29ff315e058816723f0edaf05">More...</a><br /></td></tr>
<tr class="separator:a86feb2e29ff315e058816723f0edaf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52076653fdf92dced3156a33ebe96f82"><td class="memTemplParams" colspan="2">template&lt;typename MetricT , typename QueryT , typename std::enable_if&lt; IsBoundedN&lt; QueryT, N &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a52076653fdf92dced3156a33ebe96f82"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a52076653fdf92dced3156a33ebe96f82">monotonePruningDistance</a> (<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *node, QueryT const &amp;query, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> query_bounds) const </td></tr>
<tr class="memdesc:a52076653fdf92dced3156a33ebe96f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a lower bound on (the monotone approximation to) the distance between the bounding box of a kd-tree node and a bounded query object, or a negative value if no such lower bound can be calculated.  <a href="#a52076653fdf92dced3156a33ebe96f82">More...</a><br /></td></tr>
<tr class="separator:a52076653fdf92dced3156a33ebe96f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52076653fdf92dced3156a33ebe96f82"><td class="memTemplParams" colspan="2">template&lt;typename MetricT , typename QueryT , typename std::enable_if&lt; !IsBoundedN&lt; QueryT, N &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a52076653fdf92dced3156a33ebe96f82"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a52076653fdf92dced3156a33ebe96f82">monotonePruningDistance</a> (<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *node, QueryT const &amp;query, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> query_bounds) const </td></tr>
<tr class="memdesc:a52076653fdf92dced3156a33ebe96f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a lower bound on (the monotone approximation to) the distance between the bounding box of a kd-tree node and an unbounded query object, or a negative value if no such lower bound can be calculated.  <a href="#a52076653fdf92dced3156a33ebe96f82">More...</a><br /></td></tr>
<tr class="separator:a52076653fdf92dced3156a33ebe96f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8e1bf139acb04910eef7f10c55f88b"><td class="memTemplParams" colspan="2">template&lt;typename IntersectionTesterT , typename FunctorArgT , typename RangeT , typename FunctorT &gt; </td></tr>
<tr class="memitem:aeb8e1bf139acb04910eef7f10c55f88b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#aeb8e1bf139acb04910eef7f10c55f88b">processRangeUntil</a> (<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *start, RangeT const &amp;range, FunctorT functor)</td></tr>
<tr class="memdesc:aeb8e1bf139acb04910eef7f10c55f88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to all elements of a subtree within a range, until the functor returns true.  <a href="#aeb8e1bf139acb04910eef7f10c55f88b">More...</a><br /></td></tr>
<tr class="separator:aeb8e1bf139acb04910eef7f10c55f88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8354c3c61ed39ad3d8a250adbed41e4"><td class="memTemplParams" colspan="2">template&lt;typename RayIntersectionTesterT &gt; </td></tr>
<tr class="memitem:af8354c3c61ed39ad3d8a250adbed41e4"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#af8354c3c61ed39ad3d8a250adbed41e4">rayIntersectionTime</a> (<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *start, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a371f4385228bd62d1d868083b584ee2f">RayT</a> const &amp;ray, Real max_time) const </td></tr>
<tr class="memdesc:af8354c3c61ed39ad3d8a250adbed41e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time taken for a ray to hit the nearest object in a node, in the forward direction.  <a href="#af8354c3c61ed39ad3d8a250adbed41e4">More...</a><br /></td></tr>
<tr class="separator:af8354c3c61ed39ad3d8a250adbed41e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a331493874a4f5e65e61c0941cae81"><td class="memTemplParams" colspan="2">template&lt;typename RayIntersectionTesterT &gt; </td></tr>
<tr class="memitem:a76a331493874a4f5e65e61c0941cae81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab170f96ea50d059e02bb13d8ab8f5413">RayStructureIntersectionT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a76a331493874a4f5e65e61c0941cae81">rayStructureIntersection</a> (<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *start, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a371f4385228bd62d1d868083b584ee2f">RayT</a> const &amp;ray, Real max_time) const </td></tr>
<tr class="memdesc:a76a331493874a4f5e65e61c0941cae81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nearest intersection of a ray with a node in the forward direction.  <a href="#a76a331493874a4f5e65e61c0941cae81">More...</a><br /></td></tr>
<tr class="separator:a76a331493874a4f5e65e61c0941cae81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47cc1a57fc9af78be66315314c2e4c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab47cc1a57fc9af78be66315314c2e4c4">updateBounds</a> () const </td></tr>
<tr class="memdesc:ab47cc1a57fc9af78be66315314c2e4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recompute the bounding box if it has been invalidated.  <a href="#ab47cc1a57fc9af78be66315314c2e4c4">More...</a><br /></td></tr>
<tr class="separator:ab47cc1a57fc9af78be66315314c2e4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aa6c685c5cecf619ee21ca308f870b8dd"><td class="memTemplParams" colspan="2">template&lt;typename U , typename std::enable_if&lt; IsBoundedN&lt; U, N &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa6c685c5cecf619ee21ca308f870b8dd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#aa6c685c5cecf619ee21ca308f870b8dd">getObjectBounds</a> (U const &amp;u, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> &amp;bounds)</td></tr>
<tr class="memdesc:aa6c685c5cecf619ee21ca308f870b8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounding box for an object, if it is bounded.  <a href="#aa6c685c5cecf619ee21ca308f870b8dd">More...</a><br /></td></tr>
<tr class="separator:aa6c685c5cecf619ee21ca308f870b8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c685c5cecf619ee21ca308f870b8dd"><td class="memTemplParams" colspan="2">template&lt;typename U , typename std::enable_if&lt; !IsBoundedN&lt; U, N &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa6c685c5cecf619ee21ca308f870b8dd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#aa6c685c5cecf619ee21ca308f870b8dd">getObjectBounds</a> (U const &amp;u, <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> &amp;bounds)</td></tr>
<tr class="memdesc:aa6c685c5cecf619ee21ca308f870b8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a null bounding box for unbounded objects.  <a href="#aa6c685c5cecf619ee21ca308f870b8dd">More...</a><br /></td></tr>
<tr class="separator:aa6c685c5cecf619ee21ca308f870b8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, int N, typename ScalarT = Real, typename NodeAttributeT = NullAttribute&gt;<br />
class Thea::Algorithms::KDTreeN&lt; T, N, ScalarT, NodeAttributeT &gt;</h3>

<p>A kd-tree for a set of bounded objects in N-space. </p>
<p>IsBoundedNN&lt;T, N&gt; must evaluate to true, and BoundedTraitsN&lt;T, N&gt; appropriately defined to compute bounding boxes of T objects. The optional template parameter <code>NodeAttributeT</code> must be default-constructible.</p>
<p>An affine transformation may be applied to the kd-tree. The tree does <em>not</em> need to be recomputed after the transformation, though all operations may be somewhat slower (the precise overhead depends on how difficult it is to compute distances, intersections etc after a transform). Normally, this means that the elements of type T should be affine transformable via <a class="el" href="../../da/da5/classThea_1_1Algorithms_1_1Transformer.html#a1ca50103ca04a294af9ecb6fdf3aa008" title="Apply a transformation to an object. ">Transformer::transform()</a>. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00110">110</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a875381ebdccdea47b5186d6ddafc7ad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d8/d00/classThea_1_1AxisAlignedBoxN.html">AxisAlignedBoxN</a>&lt;N, ScalarT&gt; <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Axis-aligned box in N-space. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00346">346</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4934da7318f3e9fc85ec5874c3be647f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a4934da7318f3e9fc85ec5874c3be647f">Element</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of elements in the kd-tree. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00341">341</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab87fbc68d23e29dcbe2614788d0deb45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab87fbc68d23e29dcbe2614788d0deb45">ElementIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of an element in the kd-tree. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00125">125</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1c4a6000e6b127e0b2dd46c9e0bc4052"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../de/df7/structThea_1_1Algorithms_1_1KDTreeNInternal_1_1ElementSample.html">KDTreeNInternal::ElementSample</a>&lt;N, ScalarT&gt; <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a1c4a6000e6b127e0b2dd46c9e0bc4052">ElementSample</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A point sample drawn from a kd-tree element, used for accelerating nearest neighbor queries. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00351">351</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c5180f373c10a232b47b1921aae5176"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef MemoryPool&lt;<a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab87fbc68d23e29dcbe2614788d0deb45">ElementIndex</a>&gt; <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0c5180f373c10a232b47b1921aae5176">IndexPool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pool for quickly allocating element indices. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00417">417</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a524288d0b46887110d7dceb459043cbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html">KDTreeN</a>&lt;<a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a1c4a6000e6b127e0b2dd46c9e0bc4052">ElementSample</a>, N, ScalarT&gt; <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a524288d0b46887110d7dceb459043cbb">NearestNeighborAccelerationStructure</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure to speed up nearest neighbor queries. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00353">353</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac54855b23107c5c176f3c16cf73995b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ProximityQueryBaseT::NeighborPair <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac54855b23107c5c176f3c16cf73995b5">NeighborPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair of neighboring elements. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00126">126</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a242d1fc2443d7f425fcf0ea558d5b679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NodeAttributeT <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a242d1fc2443d7f425fcf0ea558d5b679">NodeAttribute</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attributes attached to nodes. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00343">343</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a585b9362aef8ebf372222a703484cff1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef MemoryPool&lt;<a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a>&gt; <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a585b9362aef8ebf372222a703484cff1">NodePool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pool for quickly allocating kd-tree nodes. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00416">416</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab170f96ea50d059e02bb13d8ab8f5413"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dd/d79/classThea_1_1Algorithms_1_1RayStructureIntersectionN.html">RayQueryBaseT::RayStructureIntersectionT</a> <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab170f96ea50d059e02bb13d8ab8f5413">RayStructureIntersectionT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ray intersection structure in N-space. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00348">348</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a371f4385228bd62d1d868083b584ee2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d5/d24/classThea_1_1RayN.html">RayQueryBaseT::RayT</a> <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a371f4385228bd62d1d868083b584ee2f">RayT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ray in N-space. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00347">347</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0363e81fbb0d24325465c7c90febb959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d2/dac/classThea_1_1Transformable.html#a85809ea08c1d3b453930f67c419dd7e0">TransformableBaseT::Transform</a> <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0363e81fbb0d24325465c7c90febb959">Transform</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform applied to the kd-tree. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00127">127</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a265a253612b46abed17c61b0a5e5ce30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a265a253612b46abed17c61b0a5e5ce30">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of elements in the kd-tree (STL convention). </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00342">342</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac91769fe82094870fe51f1f13782e6a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d3/d59/classThea_1_1Algorithms_1_1ProximityQueryStructureN.html#a890d691eac7daa6c17cab30cb66c363c">ProximityQueryBaseT::VectorT</a> <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac91769fe82094870fe51f1f13782e6a6">VectorT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector in N-space. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00345">345</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0c04ec42e6cacebf66a3bb44ffa30764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html">KDTreeN</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00425">425</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af01a1a837c09a1131d545a130246ed63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html">KDTreeN</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td>
          <td class="paramname"><em>max_depth_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td>
          <td class="paramname"><em>max_elems_per_leaf_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_memory</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a list of elements. </p>
<p>InputIterator must dereference to type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Points to the first element to be added. </td></tr>
    <tr><td class="paramname">end</td><td>Points to one position beyond the last element to be added. </td></tr>
    <tr><td class="paramname">max_depth_</td><td>Maximum depth of the tree. The root is at depth zero. Use a negative argument to auto-select a suitable value. </td></tr>
    <tr><td class="paramname">max_elems_per_leaf_</td><td>Maximum number of elements in a leaf (unless the depth exceeds the maximum). Use a negative argument to auto-select a suitable value. </td></tr>
    <tr><td class="paramname">save_memory</td><td>If true, element references at inner nodes of the tree are deleted to save memory. This could slow down range searches since every positive result will only be obtained at the leaves. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00443">443</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d1b42712678c02bca7e4be6c2c06bf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html">KDTreeN</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00609">609</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a04b62feda5e8171278c168560ab973b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deallocate_all_memory</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the tree. </p>
<p>If <em>deallocate_all_memory</em> is false, memory allocated in pools is held to be reused if possible by the next <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a82bf07e86660e315c666e3dd91872f71" title="Construct from a list of elements. ">init()</a> operation. </p>

<p>Reimplemented in <a class="el" href="../../dc/d9c/classThea_1_1Algorithms_1_1MeshKDTree.html#a97ad9dafd345226249404dba990f4670">MeshKDTree&lt; MeshT, NodeAttributeT &gt;</a>.</p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00696">696</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5194d53d0d61f07f51f0a8164664ff8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear any existing transform. </p>

<p>Reimplemented from <a class="el" href="../../d2/dac/classThea_1_1Transformable.html#a891be44663169deca0f3598c29b21a83">Transformable&lt; AffineTransformN&lt; N, ScalarT &gt; &gt;</a>.</p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00681">681</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="addf443292546df41e4b298acb76e7e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> closestElement </td>
          <td>(</td>
          <td class="paramtype">QueryT const &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist_bound</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dist</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac91769fe82094870fe51f1f13782e6a6">VectorT</a> *&#160;</td>
          <td class="paramname"><em>closest_point</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the closest element in this structure to a query object, within a specified distance bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Query object. </td></tr>
    <tr><td class="paramname">dist_bound</td><td>Upper bound on the distance between any pair of points considered. Ignored if negative. </td></tr>
    <tr><td class="paramname">dist</td><td>The distance to the query object is placed here. Ignored if null. </td></tr>
    <tr><td class="paramname">closest_point</td><td>The coordinates of the closest point are placed here. Ignored if null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-negative handle to the closest element, if one was found, else a negative number. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00806">806</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41057802be63897099f3db13f1decf5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac54855b23107c5c176f3c16cf73995b5">NeighborPair</a> closestPair </td>
          <td>(</td>
          <td class="paramtype">QueryT const &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist_bound</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_closest_points</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the closest pair of elements between this structure and another structure, whose separation is less than a specified upper bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Query object. BoundedTraitsN&lt;QueryT, N, ScalarT&gt; must be defined. </td></tr>
    <tr><td class="paramname">dist_bound</td><td>Upper bound on the distance between any pair of points considered. Ignored if negative. </td></tr>
    <tr><td class="paramname">get_closest_points</td><td>If true, the coordinates of the closest pair of points on the respective elements is computed and stored in the returned structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative handles to the closest pair of elements in their respective objects, if such a pair was found. Else returns a pair of negative numbers. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00833">833</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2bdb8d39ec0eaba54740f01767927643"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void closestPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryT const &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> const &amp;&#160;</td>
          <td class="paramname"><em>query_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ac54855b23107c5c176f3c16cf73995b5">NeighborPair</a> &amp;&#160;</td>
          <td class="paramname"><em>pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_closest_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively look for the closest pair of points between two elements. </p>
<p>Only pairs separated by less than the current minimum distance (as stored in <em>pair</em>) will be considered. If <em>get_closest_points</em> is true, the positions of the closest pair of points will be stored in <em>pair</em>, not just the distance between them. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01293">1293</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5315740fc19e420f9afe90261bb84c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void createTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0c5180f373c10a232b47b1921aae5176">IndexPool</a> *&#160;</td>
          <td class="paramname"><em>main_index_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0c5180f373c10a232b47b1921aae5176">IndexPool</a> *&#160;</td>
          <td class="paramname"><em>leaf_index_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively construct a (sub-)tree. </p>
<p>If <em>save_memory</em> is true, element indices for this subtree are assumed to be in a block at the end of <em>main_index_pool</em>. They are subsequently moved to arrays associated with the leaves, allocated in <em>leaf_index_pool</em>. They are deleted from <em>main_index_pool</em> when this function exits, thus deallocating index arrays held by internal nodes. If <em>save_memory</em> is false, each node maintains its own list of all elements in its subtree.</p>
<dl class="section note"><dt>Note</dt><dd>To use this function with a node accessed via <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a96e6b100197f0fa9d27784a7a6293aab" title="Get the node corresponding to the root of the kd-tree. ">getRoot()</a>, you'll have to const_cast it to a non-const type first. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01102">1102</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a96d2213825c6bf28342773ac425238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disableNearestNeighborAcceleration </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deallocate_memory</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable acceleration of nearest neighbor queries with an auxiliary structure on a sparse set of points. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a80efb6a0fb227ff77596fac6e21eea21" title="Enable acceleration of nearest neighbor queries with an auxiliary structure on a sparse set of points...">enableNearestNeighborAcceleration()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00646">646</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9ac8a2ac42b7f67a21f5bb6319d3dc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double distance </td>
          <td>(</td>
          <td class="paramtype">QueryT const &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist_bound</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum distance between this structure and a query object. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00786">786</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76b6d512e48ed4caf085ac34177b7051"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool elementPassesFilters </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an element passes all filters currently on the stack. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01230">1230</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80efb6a0fb227ff77596fac6e21eea21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enableNearestNeighborAcceleration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td>
          <td class="paramname"><em>num_acceleration_samples_</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable acceleration of nearest neighbor queries with an auxiliary structure on a sparse set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_acceleration_samples_</td><td>Number of sampled points in the acceleration structure. If this number is zero, no structure will be created. If it is negative, the number will be automatically determined as a fraction of the number of elements. In the latter case, if the number is very small, no structure will be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a4a96d2213825c6bf28342773ac425238" title="Disable acceleration of nearest neighbor queries with an auxiliary structure on a sparse set of point...">disableNearestNeighborAcceleration()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00620">620</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acaccc93fb5e4c3614a4f9bf154235093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> const&amp; getBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a bounding box for all the objects in the tree. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00742">742</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2ec6c2c2283541f93db84116a1315a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> getBoundsWorldSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a bounding box for a node, in world space. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01280">1280</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab99adbb805fa0ec695da093ee855a02b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T const* getElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to an array of the elements in the tree. </p>
<p>The number of elements can be obtained with <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a933c5a6612b1378198c92b1a51ccd808" title="Get the number of elements in the tree. ">numElements()</a>. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00719">719</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae75ab2a335cc16872c6e14fc15949b56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0c5180f373c10a232b47b1921aae5176">IndexPool</a>&amp; getIndexPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the main memory pool for indices. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01078">1078</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1fe7e195b96ae7b031adbf04e6f20278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a524288d0b46887110d7dceb459043cbb">NearestNeighborAccelerationStructure</a> const* getNearestNeighborAccelerationStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the auxiliary structure to accelerate nearest neighbor queries, if available. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00659">659</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5b658e35cf4636403c454775705287d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a585b9362aef8ebf372222a703484cff1">NodePool</a>&amp; getNodePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the main memory pool for nodes. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01075">1075</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6c685c5cecf619ee21ca308f870b8dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void getObjectBounds </td>
          <td>(</td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bounding box for an object, if it is bounded. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01243">1243</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6c685c5cecf619ee21ca308f870b8dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void getObjectBounds </td>
          <td>(</td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a null bounding box for unbounded objects. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01250">1250</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96e6b100197f0fa9d27784a7a6293aab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const* getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node corresponding to the root of the kd-tree. </p>
<p>This function is provided so that users can implement their own tree traversal procedures.</p>
<p>This function cannot be used to change the structure of the tree, or any value in it (unless <code>const_cast</code> is used, which is not recommended).</p>
<dl class="section note"><dt>Note</dt><dd>An empty tree has a null root. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00730">730</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2fae8384e3a66bcdd66f486c3aea194"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0363e81fbb0d24325465c7c90febb959">Transform</a> const&amp; getTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the transformation, if one has been set. </p>
<p>Else, the return value is undefined. </p>

<p>Definition at line <a class="el" href="../../d9/db4/Transformable_8hpp_source.html#l00047">47</a> of file <a class="el" href="../../d9/db4/Transformable_8hpp_source.html">Transformable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8032ce8490b139f6491c1fe23f4fa85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0363e81fbb0d24325465c7c90febb959">Transform</a>&amp; getTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the transformation, if one has been set. </p>
<p>Else, the return value is undefined. </p>

<p>Definition at line <a class="el" href="../../d9/db4/Transformable_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d9/db4/Transformable_8hpp_source.html">Transformable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5776e04011ede490c95efe6af77613a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d17/classThea_1_1AffineTransformN.html">AffineTransformN</a>&lt;N, ScalarT&gt; const&amp; getTransformInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inverse of the transform applied to the kd-tree. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01069">1069</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab03d54a8bbcb4ad933573d1cfbab11d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a97ebcfaed8995f9f4231bb51135c6a21">Matrix</a>&lt;N, N, ScalarT&gt; const&amp; getTransformInverseTranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the transpose of the inverse of the linear part of the transform applied to the kd-tree. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01072">1072</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef15c549121a48e056a39a4170f943ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hasNearestNeighborAcceleration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if nearest neighbor queries are accelerated by an auxiliary structure. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00653">653</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade9cd00d6d0ca5c0515f3f7596640b28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a transform has been set. </p>

<p>Definition at line <a class="el" href="../../d9/db4/Transformable_8hpp_source.html#l00044">44</a> of file <a class="el" href="../../d9/db4/Transformable_8hpp_source.html">Transformable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82bf07e86660e315c666e3dd91872f71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td>
          <td class="paramname"><em>max_depth_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td>
          <td class="paramname"><em>max_elems_per_leaf_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_memory</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deallocate_previous_memory</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a list of elements. </p>
<p>InputIterator must dereference to type T. Any previous data is discarded. If any filters are active at this time, only those input elements that pass the filters will be retained in the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Points to the first element to be added. </td></tr>
    <tr><td class="paramname">end</td><td>Points to one position beyond the last element to be added. </td></tr>
    <tr><td class="paramname">max_depth_</td><td>Maximum depth of the tree. The root is at depth zero. Use a negative argument to auto-select a suitable value. </td></tr>
    <tr><td class="paramname">max_elems_per_leaf_</td><td>Maximum number of elements in a leaf (unless the depth exceeds the maximum). Use a negative argument to auto-select a suitable value. </td></tr>
    <tr><td class="paramname">save_memory</td><td>If true, element references at inner nodes of the tree are deleted to save memory. This could slow down range searches since every positive result will only be obtained at the leaves. </td></tr>
    <tr><td class="paramname">deallocate_previous_memory</td><td>If true, all previous data held in internal memory pools is explicitly deallocated. Else, all such space is reused and overwritten when possible. If <em>save_memory</em> is true, or some filters are active, this flag may not be quite as effective since it's more likely that some space will be allocated/deallocated. Note that if this flag is set to false, the space used internally by the kd-tree will not decrease except in some special implementation-specific cases. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00470">470</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a074e3a8329c1d56076c6a097d1e595f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void invalidateBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark that the bounding box requires an update. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01205">1205</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a479432127ee77145cc19d6a2d1590821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the tree is empty. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00713">713</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89ff95c512dee13ebb81b32bf810ecc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> kClosestPairs </td>
          <td>(</td>
          <td class="paramtype">QueryT const &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundedNeighborPairSetT &amp;&#160;</td>
          <td class="paramname"><em>k_closest_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist_bound</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_closest_points</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_set</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td>
          <td class="paramname"><em>use_as_query_index_and_swap</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the k elements closest to a query object. </p>
<p>The returned elements are placed in a set of bounded size (k). The template type BoundedNeighborPairSetT should typically be BoundedSortedArray&lt;NeighborPair&gt; or BoundedSortedArrayN&lt;k, NeighborPair&gt; if only a few neighbors are requested. BoundedTraitsN&lt;QueryT, N, ScalarT&gt; must be defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Query object. BoundedTraitsN&lt;QueryT, N, ScalarT&gt; must be defined. </td></tr>
    <tr><td class="paramname">k_closest_pairs</td><td>The k (or fewer) nearest neighbors are placed here. </td></tr>
    <tr><td class="paramname">dist_bound</td><td>Upper bound on the distance between any pair of points considered. Ignored if negative. </td></tr>
    <tr><td class="paramname">get_closest_points</td><td>If true, the coordinates of the closest pair of points on each pair of neighboring elements is computed and stored in the returned pairs. </td></tr>
    <tr><td class="paramname">clear_set</td><td>If true (default), this function discards prior data in <em>k_closest_pairs</em>. This is chiefly for internal use and the default value of true should normally be left as is. </td></tr>
    <tr><td class="paramname">use_as_query_index_and_swap</td><td>If non-negative, the supplied index is used as the index of the query object (instead of the default 0), following which query and target indices/points are swapped in the returned pairs of neighbors. This is chiefly for internal use and the default value of -1 should normally be left as is.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of neighbors found (i.e. the size of <em>k_closest_pairs</em>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>k-closest pairs <b>cannot</b> be accelerated by the auxiliary structure created by <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a80efb6a0fb227ff77596fac6e21eea21" title="Enable acceleration of nearest neighbor queries with an auxiliary structure on a sparse set of points...">enableNearestNeighborAcceleration()</a>. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00884">884</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86feb2e29ff315e058816723f0edaf05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kClosestPairs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryT const &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a> const &amp;&#160;</td>
          <td class="paramname"><em>query_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundedNeighborPairSet &amp;&#160;</td>
          <td class="paramname"><em>k_closest_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_closest_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a>&#160;</td>
          <td class="paramname"><em>use_as_query_index_and_swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively look for the k closest elements to a query object. </p>
<p>Only elements at less than the specified maximum distance <em>dist_bound</em> will be considered. If <em>get_closest_points</em> is true, the positions of the closest pair of points will be stored with each pair, not just the distance between them. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01395">1395</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8236ea4ff413ae88c2eb98ec0e32af7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> maxDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum subdivision depth (number of levels not counting the root) of the kd-tree. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00736">736</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab28b0f742ad94b0e5b582e4b618509a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> maxElementsPerLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of elements in each leaf of the kd-tree. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00739">739</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52076653fdf92dced3156a33ebe96f82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double monotonePruningDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryT const &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a>&#160;</td>
          <td class="paramname"><em>query_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a lower bound on (the monotone approximation to) the distance between the bounding box of a kd-tree node and a bounded query object, or a negative value if no such lower bound can be calculated. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01260">1260</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52076653fdf92dced3156a33ebe96f82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double monotonePruningDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryT const &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a875381ebdccdea47b5186d6ddafc7ad2">AxisAlignedBoxT</a>&#160;</td>
          <td class="paramname"><em>query_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a lower bound on (the monotone approximation to) the distance between the bounding box of a kd-tree node and an unbounded query object, or a negative value if no such lower bound can be calculated. </p>
<p><em>query_bounds</em> is ignored. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01273">1273</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a933c5a6612b1378198c92b1a51ccd808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> numElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of elements in the tree. </p>
<p>The elements themselves can be obtained with <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab99adbb805fa0ec695da093ee855a02b" title="Get a pointer to an array of the elements in the tree. ">getElements()</a>. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00716">716</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeae54574dd3a837be054a38deb73fe0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> numNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of nodes in the tree. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00733">733</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f66d5fae81b5d5e30d823c2e133b826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void popFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the last pushed element filter off the filter stack. </p>
<p>Must be matched with a preceding <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a7b54e2357eee85dffac2ede1da3fee3c" title="Push an element filter onto the filter stack. ">pushFilter()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a7b54e2357eee85dffac2ede1da3fee3c" title="Push an element filter onto the filter stack. ">pushFilter()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00774">774</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad80159a5aed74b3117617a960bb9b874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> processRangeUntil </td>
          <td>(</td>
          <td class="paramtype">RangeT const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctorT&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a functor to all objects in a range, until the functor returns true. </p>
<p>The functor should provide the member function (or be a function pointer with the equivalent signature) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator()(<a class="code" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> index, T <span class="keyword">const</span> &amp; t)</div></div><!-- fragment --><p> and will be passed the index of each object contained in the range as well as a handle to the object itself. If the functor returns true on any object, the search will terminate immediately (this is useful for searching for a particular object). To pass a functor by reference, wrap it in <code>std::ref</code>.</p>
<p>The RangeT class should support intersection queries with AxisAlignedBoxT and containment queries with VectorT and AxisAlignedBoxT.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first object in the range for which the functor evaluated to true (the search stopped immediately after processing this object), else a negative value. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00963">963</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8717983c70e7973213935b68cca6552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> processRangeUntil </td>
          <td>(</td>
          <td class="paramtype">RangeT const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctorT&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a functor to all objects in a range, until the functor returns true. </p>
<p>The functor should provide the member function (or be a function pointer with the equivalent signature) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator()(<a class="code" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> index, T [<span class="keyword">const</span>] &amp; t)</div></div><!-- fragment --><p> and will be passed the index of each object contained in the range as well as a handle to the object itself. If the functor returns true on any object, the search will terminate immediately (this is useful for searching for a particular object). To pass a functor by reference, wrap it in <code>std::ref</code>.</p>
<p>The RangeT class should support intersection queries with AxisAlignedBoxT and containment queries with VectorT and AxisAlignedBoxT.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first object in the range for which the functor evaluated to true (the search stopped immediately after processing this object), else a negative value. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00985">985</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb8e1bf139acb04910eef7f10c55f88b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> processRangeUntil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeT const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctorT&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to all elements of a subtree within a range, until the functor returns true. </p>
<p>The functor should provide the member function (or be a function pointer with the equivalent signature) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator()(<a class="code" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> index, T &amp; t)</div></div><!-- fragment --><p> and will be passed the index of each object contained in the range as well as a handle to the object itself. If the functor returns true on any object, the search will terminate immediately (this is useful for searching for a particular object). To pass a functor by reference, wrap it in <code>std::ref</code></p>
<p>The RangeT class should support intersection queries with AxisAlignedBoxT and containment queries with VectorT and AxisAlignedBoxT.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first object in the range for which the functor evaluated to true (the search stopped immediately after processing this object), else a negative value. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01541">1541</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b54e2357eee85dffac2ede1da3fee3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pushFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/df0/classThea_1_1Algorithms_1_1Filter.html">Filter</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push an element filter onto the filter stack. </p>
<p>Elements in the tree that are not passed by all filters currently on the stack are ignored for all operations, including <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a82bf07e86660e315c666e3dd91872f71" title="Construct from a list of elements. ">init()</a>.</p>
<p>The filter must persist until it is popped off. Must be matched with <a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a7f66d5fae81b5d5e30d823c2e133b826" title="Pops the last pushed element filter off the filter stack. ">popFilter()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a7f66d5fae81b5d5e30d823c2e133b826" title="Pops the last pushed element filter off the filter stack. ">popFilter()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00756">756</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb4a41300a564c8bb25c7d0f44e4a93b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rangeQuery </td>
          <td>(</td>
          <td class="paramtype">RangeT const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#abb257f9b3a48e93d3c1c12d1b307d59f">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discard_prior_results</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all objects intersecting a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to search in. </td></tr>
    <tr><td class="paramname">result</td><td>The objects intersecting the range are stored here. </td></tr>
    <tr><td class="paramname">discard_prior_results</td><td>If true, the contents of <em>results</em> are cleared before the range query proceeds. If false, the previous results are retained and new objects are appended to the array (this is useful for range queries over a union of simpler ranges). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00924">924</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada82d381561e5c3c020ab34db3725fa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rangeQueryIndices </td>
          <td>(</td>
          <td class="paramtype">RangeT const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d8a/namespaceThea.html#abb257f9b3a48e93d3c1c12d1b307d59f">Array</a>&lt; <a class="el" href="../../d8/d8a/namespaceThea.html#a664b620b827057bcc5bd67f26c47b29b">intx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discard_prior_results</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the indices of all objects intersecting a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to search in. </td></tr>
    <tr><td class="paramname">result</td><td>The indices of objects intersecting the range are stored here. </td></tr>
    <tr><td class="paramname">discard_prior_results</td><td>If true, the contents of <em>results</em> are cleared before the range query proceeds. If false, the previous results are retained and indices of new objects are appended to the array (this is useful for range queries over a union of simpler ranges). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00940">940</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8354c3c61ed39ad3d8a250adbed41e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real rayIntersectionTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a371f4385228bd62d1d868083b584ee2f">RayT</a> const &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>max_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the time taken for a ray to hit the nearest object in a node, in the forward direction. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01618">1618</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76a331493874a4f5e65e61c0941cae81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#ab170f96ea50d059e02bb13d8ab8f5413">RayStructureIntersectionT</a> rayStructureIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df8/classThea_1_1Algorithms_1_1KDTreeN_1_1Node.html">Node</a> const *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a371f4385228bd62d1d868083b584ee2f">RayT</a> const &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>max_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the nearest intersection of a ray with a node in the forward direction. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01679">1679</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a319f007dd993d2c8f8e64c676ae0ac13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d77/classThea_1_1Algorithms_1_1KDTreeN.html#a0363e81fbb0d24325465c7c90febb959">Transform</a> const &amp;&#160;</td>
          <td class="paramname"><em>trans_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the transformation. </p>

<p>Reimplemented from <a class="el" href="../../d2/dac/classThea_1_1Transformable.html#af380eadf4587148cf5788fdad8c08e82">Transformable&lt; AffineTransformN&lt; N, ScalarT &gt; &gt;</a>.</p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l00670">670</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab47cc1a57fc9af78be66315314c2e4c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void updateBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recompute the bounding box if it has been invalidated. </p>

<p>Definition at line <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html#l01211">1211</a> of file <a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="../../d8/dfd/KDTreeN_8hpp_source.html">KDTreeN.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
